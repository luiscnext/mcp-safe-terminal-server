/**\n * Comprehensive logging system for security auditing and monitoring\n * Provides structured logging with security event tracking\n */\n\nimport winston from 'winston';\nimport path from 'path';\nimport { AuditLogEntry, LogLevel, ActionType } from '../types/interfaces.js';\n\n/**\n * Custom log format for structured JSON logging\n */\nconst logFormat = winston.format.combine(\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),\n  winston.format.errors({ stack: true }),\n  winston.format.json(),\n  winston.format.printf((info) => {\n    const { timestamp, level, message, ...meta } = info;\n    return JSON.stringify({\n      timestamp,\n      level: level.toUpperCase(),\n      message,\n      ...meta,\n      source: 'mcp-safe-terminal-server'\n    });\n  })\n);\n\n/**\n * Security audit format for sensitive operations\n */\nconst auditFormat = winston.format.combine(\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),\n  winston.format.json(),\n  winston.format.printf((info) => {\n    const { timestamp, level, message, ...meta } = info;\n    return JSON.stringify({\n      timestamp,\n      level: 'AUDIT',\n      event_type: 'security_audit',\n      message,\n      ...meta,\n      source: 'mcp-safe-terminal-server',\n      audit_version: '1.0'\n    });\n  })\n);\n\n/**\n * Main logger class with security-focused features\n */\nexport class Logger {\n  private mainLogger: winston.Logger;\n  private auditLogger: winston.Logger;\n  private securityLogger: winston.Logger;\n  private sessionId: string;\n  private userId?: string;\n\n  constructor(\n    logLevel: LogLevel = 'info',\n    logFile: string = './logs/server.log',\n    auditLogFile: string = './logs/audit.log',\n    sessionId: string = 'default'\n  ) {\n    this.sessionId = sessionId;\n    \n    // Ensure log directories exist\n    this.ensureLogDirectories([logFile, auditLogFile]);\n\n    // Main application logger\n    this.mainLogger = winston.createLogger({\n      level: logLevel,\n      format: logFormat,\n      transports: [\n        new winston.transports.File({ \n          filename: logFile,\n          maxsize: 10 * 1024 * 1024, // 10MB\n          maxFiles: 5,\n          tailable: true\n        }),\n        new winston.transports.Console({\n          format: winston.format.combine(\n            winston.format.colorize(),\n            winston.format.simple()\n          )\n        })\n      ]\n    });\n\n    // Security audit logger (separate file for compliance)\n    this.auditLogger = winston.createLogger({\n      level: 'info',\n      format: auditFormat,\n      transports: [\n        new winston.transports.File({ \n          filename: auditLogFile,\n          maxsize: 50 * 1024 * 1024, // 50MB for audit logs\n          maxFiles: 10,\n          tailable: true\n        })\n      ]\n    });\n\n    // Security event logger (high-priority security events)\n    this.securityLogger = winston.createLogger({\n      level: 'warn',\n      format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.errors({ stack: true }),\n        winston.format.json(),\n        winston.format.printf((info) => {\n          return JSON.stringify({\n            ...info,\n            event_type: 'security_event',\n            severity: 'HIGH',\n            requires_attention: true\n          });\n        })\n      ),\n      transports: [\n        new winston.transports.File({ \n          filename: path.join(path.dirname(auditLogFile), 'security-events.log'),\n          maxsize: 25 * 1024 * 1024, // 25MB\n          maxFiles: 5\n        }),\n        new winston.transports.Console({\n          level: 'error',\n          format: winston.format.combine(\n            winston.format.colorize(),\n            winston.format.simple()\n          )\n        })\n      ]\n    });\n\n    // Log logger initialization\n    this.info('Logger initialized', {\n      logLevel,\n      logFile,\n      auditLogFile,\n      sessionId\n    });\n  }\n\n  /**\n   * Set user context for all subsequent logs\n   */\n  public setUserContext(userId: string): void {\n    this.userId = userId;\n    this.info('User context set', { userId });\n  }\n\n  /**\n   * Standard logging methods\n   */\n  public debug(message: string, meta: any = {}): void {\n    this.mainLogger.debug(message, {\n      ...meta,\n      sessionId: this.sessionId,\n      userId: this.userId\n    });\n  }\n\n  public info(message: string, meta: any = {}): void {\n    this.mainLogger.info(message, {\n      ...meta,\n      sessionId: this.sessionId,\n      userId: this.userId\n    });\n  }\n\n  public warn(message: string, meta: any = {}): void {\n    this.mainLogger.warn(message, {\n      ...meta,\n      sessionId: this.sessionId,\n      userId: this.userId\n    });\n  }\n\n  public error(message: string, meta: any = {}): void {\n    this.mainLogger.error(message, {\n      ...meta,\n      sessionId: this.sessionId,\n      userId: this.userId,\n      stack: meta.error?.stack\n    });\n  }\n\n  /**\n   * Security audit logging for compliance\n   */\n  public audit(entry: Omit<AuditLogEntry, 'timestamp' | 'sessionId'>): void {\n    const auditEntry: AuditLogEntry = {\n      ...entry,\n      timestamp: new Date(),\n      sessionId: this.sessionId,\n      userId: entry.userId || this.userId\n    };\n\n    this.auditLogger.info('Security audit entry', auditEntry);\n\n    // Also log to main logger for visibility\n    this.info(`Audit: ${entry.action}`, {\n      action: entry.action,\n      success: entry.success,\n      command: entry.command,\n      reason: entry.reason\n    });\n  }\n\n  /**\n   * Log command execution attempts\n   */\n  public logCommandExecution(\n    command: string,\n    args: string[],\n    success: boolean,\n    reason?: string,\n    duration?: number,\n    outputSize?: number\n  ): void {\n    this.audit({\n      action: success ? 'command_executed' : 'command_blocked',\n      command,\n      args,\n      success,\n      reason,\n      ipAddress: undefined, // Will be set by server\n      userAgent: undefined  // Will be set by server\n    });\n\n    if (success && duration !== undefined) {\n      this.info('Command completed', {\n        command,\n        args,\n        duration,\n        outputSize\n      });\n    }\n  }\n\n  /**\n   * Log authentication attempts\n   */\n  public logAuthAttempt(\n    success: boolean,\n    reason?: string,\n    ipAddress?: string,\n    userAgent?: string\n  ): void {\n    this.audit({\n      action: 'auth_attempt',\n      success,\n      reason,\n      ipAddress,\n      userAgent\n    });\n\n    if (!success) {\n      this.securityEvent('Authentication failure', {\n        reason,\n        ipAddress,\n        userAgent,\n        severity: 'MEDIUM'\n      });\n    }\n  }\n\n  /**\n   * Log rate limiting events\n   */\n  public logRateLimit(\n    ipAddress?: string,\n    userAgent?: string,\n    reason?: string\n  ): void {\n    this.audit({\n      action: 'rate_limit_hit',\n      success: false,\n      reason: reason || 'Rate limit exceeded',\n      ipAddress,\n      userAgent\n    });\n\n    this.securityEvent('Rate limit exceeded', {\n      ipAddress,\n      userAgent,\n      reason,\n      severity: 'MEDIUM'\n    });\n  }\n\n  /**\n   * Log high-priority security events\n   */\n  public securityEvent(message: string, meta: any = {}): void {\n    this.securityLogger.error(message, {\n      ...meta,\n      sessionId: this.sessionId,\n      userId: this.userId,\n      timestamp: new Date().toISOString(),\n      alert_priority: 'HIGH'\n    });\n\n    // Also log to audit trail\n    this.audit({\n      action: 'command_blocked',\n      success: false,\n      reason: message,\n      command: meta.command,\n      args: meta.args,\n      ipAddress: meta.ipAddress,\n      userAgent: meta.userAgent\n    });\n  }\n\n  /**\n   * Log suspicious activity that may indicate attacks\n   */\n  public suspiciousActivity(\n    activity: string,\n    details: any = {},\n    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'HIGH'\n  ): void {\n    this.securityEvent(`Suspicious activity detected: ${activity}`, {\n      ...details,\n      severity,\n      requires_investigation: severity === 'HIGH' || severity === 'CRITICAL',\n      automated_response: severity === 'CRITICAL'\n    });\n\n    if (severity === 'CRITICAL') {\n      // For critical events, also log to console immediately\n      console.error(`ðŸš¨ CRITICAL SECURITY EVENT: ${activity}`, details);\n    }\n  }\n\n  /**\n   * Performance logging for monitoring\n   */\n  public performance(\n    operation: string,\n    duration: number,\n    metadata: any = {}\n  ): void {\n    this.info(`Performance: ${operation}`, {\n      operation,\n      duration_ms: duration,\n      performance_category: 'execution_time',\n      ...metadata\n    });\n\n    // Log slow operations as warnings\n    if (duration > 10000) { // 10 seconds\n      this.warn(`Slow operation detected: ${operation}`, {\n        duration_ms: duration,\n        threshold_exceeded: true,\n        ...metadata\n      });\n    }\n  }\n\n  /**\n   * Create child logger with additional context\n   */\n  public child(additionalContext: any): Logger {\n    const childLogger = new Logger(\n      this.mainLogger.level as LogLevel,\n      '', // Will use parent's file\n      '', // Will use parent's audit file\n      this.sessionId\n    );\n    \n    if (this.userId) {\n      childLogger.setUserContext(this.userId);\n    }\n    \n    return childLogger;\n  }\n\n  /**\n   * Flush all logs (useful for testing and graceful shutdown)\n   */\n  public async flush(): Promise<void> {\n    return new Promise((resolve) => {\n      let pending = 3;\n      const checkDone = () => {\n        pending--;\n        if (pending === 0) resolve();\n      };\n\n      this.mainLogger.end(checkDone);\n      this.auditLogger.end(checkDone);\n      this.securityLogger.end(checkDone);\n    });\n  }\n\n  /**\n   * Get current log statistics\n   */\n  public getStats(): {\n    sessionId: string;\n    userId?: string;\n    logLevel: string;\n    transportsCount: number;\n  } {\n    return {\n      sessionId: this.sessionId,\n      userId: this.userId,\n      logLevel: this.mainLogger.level,\n      transportsCount: this.mainLogger.transports.length\n    };\n  }\n\n  /**\n   * Ensure log directories exist\n   */\n  private ensureLogDirectories(logFiles: string[]): void {\n    const fs = require('fs');\n    \n    for (const logFile of logFiles) {\n      const dir = path.dirname(logFile);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n    }\n  }\n}\n\n/**\n * Factory function to create a logger with default settings\n */\nexport function createLogger(\n  sessionId: string,\n  logLevel: LogLevel = 'info',\n  logFile?: string,\n  auditLogFile?: string\n): Logger {\n  return new Logger(\n    logLevel,\n    logFile || './logs/server.log',\n    auditLogFile || './logs/audit.log',\n    sessionId\n  );\n}\n\n/**\n * Global logger instance for convenience\n */\nlet globalLogger: Logger | null = null;\n\nexport function getGlobalLogger(): Logger {\n  if (!globalLogger) {\n    globalLogger = createLogger('global');\n  }\n  return globalLogger;\n}\n\nexport function setGlobalLogger(logger: Logger): void {\n  globalLogger = logger;\n}\n