/**\n * Main MCP Server implementation for Safe Terminal Commands\n * Integrates all security components and exposes safe terminal capabilities\n */\n\nimport { McpServer, ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { z } from 'zod';\nimport { randomUUID } from 'crypto';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nimport { InputSanitizer, createSanitizer } from './security/sanitizer.js';\nimport { SafeCommandExecutor, createSafeExecutor } from './executors/safe-executor.js';\nimport { Logger, createLogger } from './utils/logger.js';\nimport { SAFE_COMMANDS, SECURITY_LIMITS } from './security/whitelist.js';\nimport {\n  McpToolResult,\n  McpResourceContent,\n  ServerConfig,\n  CommandResult,\n  SecurityError,\n  ValidationError,\n  CommandExecutionError,\n  RateLimitError\n} from './types/interfaces.js';\n\n// Get current directory for ES modules\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Rate limiting store (in production, use Redis or similar)\n */\nclass SimpleRateLimiter {\n  private requests: Map<string, { count: number; resetTime: number }> = new Map();\n  private maxRequests: number;\n  private windowMs: number;\n\n  constructor(maxRequests: number = 30, windowMs: number = 60000) {\n    this.maxRequests = maxRequests;\n    this.windowMs = windowMs;\n  }\n\n  isAllowed(identifier: string): boolean {\n    const now = Date.now();\n    const key = identifier;\n    const current = this.requests.get(key);\n\n    if (!current || now > current.resetTime) {\n      this.requests.set(key, { count: 1, resetTime: now + this.windowMs });\n      return true;\n    }\n\n    if (current.count >= this.maxRequests) {\n      return false;\n    }\n\n    current.count++;\n    return true;\n  }\n\n  getRemainingRequests(identifier: string): number {\n    const current = this.requests.get(identifier);\n    if (!current || Date.now() > current.resetTime) {\n      return this.maxRequests;\n    }\n    return Math.max(0, this.maxRequests - current.count);\n  }\n}\n\n/**\n * Main Safe Terminal MCP Server\n */\nexport class SafeTerminalMcpServer {\n  private server: McpServer;\n  private sanitizer: InputSanitizer;\n  private executor: SafeCommandExecutor;\n  private logger: Logger;\n  private rateLimiter: SimpleRateLimiter;\n  private config: ServerConfig;\n  private commandHistory: CommandResult[] = [];\n  private sessionId: string;\n\n  constructor(config: Partial<ServerConfig> = {}) {\n    this.sessionId = randomUUID();\n    \n    // Default configuration\n    this.config = {\n      port: 3000,\n      host: 'localhost',\n      maxRequestsPerMinute: 30,\n      commandTimeoutMs: 30000,\n      maxOutputSizeBytes: 1024 * 1024, // 1MB\n      allowedDirectories: [process.cwd()],\n      defaultWorkingDir: process.cwd(),\n      enableGitCommands: true,\n      enableNpmCommands: true,\n      enableSystemInfo: true,\n      logLevel: 'info',\n      logFile: './logs/server.log',\n      auditLogFile: './logs/audit.log',\n      ...config\n    };\n\n    // Initialize components\n    this.logger = createLogger(\n      this.sessionId,\n      this.config.logLevel,\n      this.config.logFile,\n      this.config.auditLogFile\n    );\n\n    this.sanitizer = createSanitizer(\n      this.config.allowedDirectories,\n      this.config.defaultWorkingDir\n    );\n\n    this.executor = createSafeExecutor(this.sanitizer, this.logger, {\n      timeout: this.config.commandTimeoutMs,\n      maxOutputSize: this.config.maxOutputSizeBytes,\n      cwd: this.config.defaultWorkingDir\n    });\n\n    this.rateLimiter = new SimpleRateLimiter(\n      this.config.maxRequestsPerMinute,\n      60000 // 1 minute\n    );\n\n    // Initialize MCP server\n    this.server = new McpServer({\n      name: process.env.MCP_SERVER_NAME || 'Safe Terminal Server',\n      version: process.env.MCP_SERVER_VERSION || '1.0.0'\n    });\n\n    this.setupTools();\n    this.setupResources();\n    this.setupPrompts();\n\n    this.logger.info('Safe Terminal MCP Server initialized', {\n      config: this.config,\n      sessionId: this.sessionId\n    });\n  }\n\n  /**\n   * Setup MCP tools for safe command execution\n   */\n  private setupTools(): void {\n    // Main tool for executing safe commands\n    this.server.tool(\n      'execute_safe_command',\n      {\n        command: z.string().describe('The command to execute (must be whitelisted)'),\n        args: z.array(z.string()).optional().describe('Command arguments'),\n        workingDirectory: z.string().optional().describe('Working directory (must be within allowed paths)')\n      },\n      async ({ command, args = [], workingDirectory }) => {\n        return this.handleCommandExecution(command, args, workingDirectory);\n      }\n    );\n\n    // Tool to list available commands\n    this.server.tool(\n      'list_available_commands',\n      {},\n      async () => {\n        return this.handleListCommands();\n      }\n    );\n\n    // Tool to validate a command without executing it\n    this.server.tool(\n      'validate_command',\n      {\n        command: z.string().describe('Command to validate'),\n        args: z.array(z.string()).optional().describe('Command arguments')\n      },\n      async ({ command, args = [] }) => {\n        return this.handleValidateCommand(command, args);\n      }\n    );\n\n    // Tool to get server status and configuration\n    this.server.tool(\n      'get_server_status',\n      {},\n      async () => {\n        return this.handleServerStatus();\n      }\n    );\n\n    this.logger.info('MCP tools configured', {\n      toolCount: 4\n    });\n  }\n\n  /**\n   * Setup MCP resources for accessing logs and history\n   */\n  private setupResources(): void {\n    // Command history resource\n    this.server.resource(\n      'command_history',\n      new ResourceTemplate('history://commands/{limit?}', { list: undefined }),\n      async (uri, { limit }) => {\n        const limitNum = limit ? parseInt(limit) : 50;\n        const recentCommands = this.commandHistory.slice(-limitNum);\n        \n        return {\n          contents: [{\n            uri: uri.href,\n            text: JSON.stringify(recentCommands, null, 2),\n            mimeType: 'application/json'\n          }]\n        };\n      }\n    );\n\n    // Security log resource\n    this.server.resource(\n      'security_log',\n      'logs://security',\n      async (uri) => {\n        // In a real implementation, you'd read from the actual log files\n        const securityEvents = {\n          session: this.sessionId,\n          timestamp: new Date().toISOString(),\n          message: 'Security log access - implement file reading here',\n          note: 'This would contain recent security events from audit logs'\n        };\n        \n        return {\n          contents: [{\n            uri: uri.href,\n            text: JSON.stringify(securityEvents, null, 2),\n            mimeType: 'application/json'\n          }]\n        };\n      }\n    );\n\n    // Server configuration resource\n    this.server.resource(\n      'server_config',\n      'config://server',\n      async (uri) => {\n        const publicConfig = {\n          allowedDirectories: this.config.allowedDirectories,\n          maxRequestsPerMinute: this.config.maxRequestsPerMinute,\n          commandTimeoutMs: this.config.commandTimeoutMs,\n          enabledFeatures: {\n            gitCommands: this.config.enableGitCommands,\n            npmCommands: this.config.enableNpmCommands,\n            systemInfo: this.config.enableSystemInfo\n          },\n          securityLimits: SECURITY_LIMITS\n        };\n        \n        return {\n          contents: [{\n            uri: uri.href,\n            text: JSON.stringify(publicConfig, null, 2),\n            mimeType: 'application/json'\n          }]\n        };\n      }\n    );\n\n    this.logger.info('MCP resources configured', {\n      resourceCount: 3\n    });\n  }\n\n  /**\n   * Setup MCP prompts for common use cases\n   */\n  private setupPrompts(): void {\n    // Prompt for exploring a project structure\n    this.server.prompt(\n      'explore_project',\n      {\n        directory: z.string().optional().describe('Directory to explore (defaults to current)')\n      },\n      ({ directory }) => ({\n        messages: [{\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please help me explore the project structure in ${directory || 'the current directory'}. Start by listing the contents, then check if it's a git repository, and look for package.json or other project files.`\n          }\n        }]\n      })\n    );\n\n    // Prompt for checking git status\n    this.server.prompt(\n      'check_git_status',\n      {},\n      () => ({\n        messages: [{\n          role: 'user',\n          content: {\n            type: 'text',\n            text: 'Please check the git status of this project, including current branch, uncommitted changes, and recent commits.'\n          }\n        }]\n      })\n    );\n\n    // Prompt for project health check\n    this.server.prompt(\n      'project_health_check',\n      {},\n      () => ({\n        messages: [{\n          role: 'user',\n          content: {\n            type: 'text',\n            text: 'Please perform a health check on this project by checking dependencies, git status, and looking for any obvious issues.'\n          }\n        }]\n      })\n    );\n\n    this.logger.info('MCP prompts configured', {\n      promptCount: 3\n    });\n  }\n\n  /**\n   * Handle safe command execution with full security controls\n   */\n  private async handleCommandExecution(\n    command: string,\n    args: string[],\n    workingDirectory?: string\n  ): Promise<McpToolResult> {\n    const startTime = Date.now();\n    const clientId = 'default'; // In production, extract from request context\n\n    try {\n      // Rate limiting check\n      if (!this.rateLimiter.isAllowed(clientId)) {\n        this.logger.logRateLimit(undefined, undefined, 'Command execution rate limit exceeded');\n        throw new RateLimitError(\n          'Rate limit exceeded. Please wait before making more requests.',\n          60\n        );\n      }\n\n      // Execute command\n      const result = await this.executor.executeCommand(command, args, {\n        cwd: workingDirectory\n      });\n\n      // Store in history\n      this.commandHistory.push(result);\n      \n      // Keep history size manageable\n      if (this.commandHistory.length > 1000) {\n        this.commandHistory = this.commandHistory.slice(-500);\n      }\n\n      // Log successful execution\n      this.logger.logCommandExecution(\n        command,\n        args,\n        true,\n        undefined,\n        result.duration,\n        result.output.length\n      );\n\n      return {\n        content: [{\n          type: 'text',\n          text: this.formatCommandResult(result)\n        }]\n      };\n\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      if (error instanceof SecurityError) {\n        this.logger.logCommandExecution(command, args, false, error.message);\n        this.logger.securityEvent('Command blocked by security validation', {\n          command,\n          args,\n          reason: error.message,\n          code: error.code\n        });\n      } else if (error instanceof RateLimitError) {\n        // Rate limit error already logged\n      } else {\n        this.logger.logCommandExecution(command, args, false, error instanceof Error ? error.message : 'Unknown error');\n      }\n\n      return {\n        content: [{\n          type: 'text',\n          text: `❌ Command execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        }],\n        isError: true\n      };\n    }\n  }\n\n  /**\n   * Handle listing available commands\n   */\n  private async handleListCommands(): Promise<McpToolResult> {\n    const categories = {\n      system: [],\n      file: [],\n      git: [],\n      npm: []\n    } as any;\n\n    for (const [key, config] of Object.entries(SAFE_COMMANDS)) {\n      categories[config.category].push({\n        name: config.name,\n        description: config.description,\n        allowedArgs: config.allowedArgs,\n        riskLevel: config.riskLevel\n      });\n    }\n\n    const output = {\n      message: 'Available safe commands by category',\n      totalCommands: Object.keys(SAFE_COMMANDS).length,\n      categories,\n      securityNote: 'All commands are strictly validated and run in a secure environment'\n    };\n\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(output, null, 2)\n      }]\n    };\n  }\n\n  /**\n   * Handle command validation without execution\n   */\n  private async handleValidateCommand(command: string, args: string[]): Promise<McpToolResult> {\n    const validation = this.executor.validateCommandOnly(command, args);\n    \n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify({\n          command,\n          args,\n          isValid: validation.isValid,\n          errors: validation.errors,\n          timestamp: new Date().toISOString()\n        }, null, 2)\n      }],\n      isError: !validation.isValid\n    };\n  }\n\n  /**\n   * Handle server status request\n   */\n  private async handleServerStatus(): Promise<McpToolResult> {\n    const stats = {\n      server: {\n        sessionId: this.sessionId,\n        uptime: process.uptime(),\n        version: process.env.MCP_SERVER_VERSION || '1.0.0',\n        nodeVersion: process.version\n      },\n      security: {\n        allowedDirectories: this.config.allowedDirectories,\n        rateLimitRemaining: this.rateLimiter.getRemainingRequests('default'),\n        commandHistorySize: this.commandHistory.length\n      },\n      execution: this.executor.getExecutionStats(),\n      logging: this.logger.getStats()\n    };\n\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(stats, null, 2)\n      }]\n    };\n  }\n\n  /**\n   * Format command result for display\n   */\n  private formatCommandResult(result: CommandResult): string {\n    const parts = [\n      `🔧 Command: ${result.command} ${result.args.join(' ')}`,\n      `📁 Directory: ${result.workingDirectory}`,\n      `⏱️  Duration: ${result.duration}ms`,\n      `✅ Exit Code: ${result.exitCode}`,\n      '',\n      '📄 Output:',\n      result.output || '(no output)',\n    ];\n\n    if (result.error) {\n      parts.push('', '❌ Errors:', result.error);\n    }\n\n    return parts.join('\\n');\n  }\n\n  /**\n   * Start the MCP server with stdio transport\n   */\n  public async startStdio(): Promise<void> {\n    const transport = new StdioServerTransport();\n    \n    this.logger.info('Starting MCP server with stdio transport');\n    \n    try {\n      await this.server.connect(transport);\n      this.logger.info('MCP server connected successfully');\n    } catch (error) {\n      this.logger.error('Failed to start MCP server', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Graceful shutdown\n   */\n  public async shutdown(): Promise<void> {\n    this.logger.info('Shutting down MCP server');\n    \n    try {\n      await this.logger.flush();\n      this.logger.info('MCP server shutdown complete');\n    } catch (error) {\n      console.error('Error during shutdown:', error);\n    }\n  }\n\n  /**\n   * Get server configuration (for testing/debugging)\n   */\n  public getConfig(): ServerConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get command history (for testing/debugging)\n   */\n  public getCommandHistory(): CommandResult[] {\n    return [...this.commandHistory];\n  }\n}\n\n/**\n * Factory function to create and configure the server\n */\nexport function createSafeTerminalServer(config?: Partial<ServerConfig>): SafeTerminalMcpServer {\n  return new SafeTerminalMcpServer(config);\n}\n