/**\n * Input sanitization and validation for command execution\n * Implements multiple layers of security to prevent command injection\n */\n\nimport path from 'path';\nimport { ValidationResult, ValidationError } from '../types/interfaces.js';\nimport { \n  SAFE_COMMANDS, \n  BLOCKED_COMMANDS, \n  SAFE_FILE_EXTENSIONS, \n  BLOCKED_FILE_PATHS,\n  SECURITY_LIMITS \n} from './whitelist.js';\n\n/**\n * Dangerous shell metacharacters that should be blocked\n */\nconst SHELL_METACHARACTERS = [\n  ';', '|', '&', '$', '`', '(', ')', '<', '>', '*', '?',\n  '[', ']', '{', '}', '\"', \"'\", '\\\\', '\\n', '\\r', '\\t'\n];\n\n/**\n * Patterns that indicate potential command injection attempts\n */\nconst INJECTION_PATTERNS = [\n  /;\\s*\\w+/,           // Command chaining with semicolon\n  /\\|\\s*\\w+/,          // Pipe to another command\n  /&&\\s*\\w+/,          // AND operator\n  /\\|\\|\\s*\\w+/,        // OR operator\n  /`[^`]*`/,           // Backticks (command substitution)\n  /\\$\\([^)]*\\)/,       // Command substitution $(...)\n  /\\$\\{[^}]*\\}/,       // Variable expansion ${...}\n  /\\\\[nrtbf]/,         // Escape sequences\n  /<\\s*\\/dev\\/null/,    // Redirect to /dev/null\n  />\\s*\\/dev\\/null/,    // Redirect from /dev/null\n  /rm\\s+-rf/i,         // Dangerous rm command\n  /sudo\\s+/i,          // Sudo escalation\n  /su\\s+/i,            // User switching\n  /chmod\\s+/i,         // Permission changes\n  /chown\\s+/i,         // Ownership changes\n  /wget\\s+/i,          // Network downloads\n  /curl\\s+/i,          // Network requests\n  /eval\\s+/i,          // Code evaluation\n  /exec\\s+/i,          // Process execution\n  /\\.\\.\\/\\.\\.\\/\\.\\.\\//, // Directory traversal\n  /\\/etc\\/passwd/,      // System file access\n  /\\/etc\\/shadow/,      // Shadow file access\n  /\\/root\\//,           // Root directory access\n  /~\\/\\.ssh\\//,         // SSH directory access\n];\n\n/**\n * Comprehensive input sanitizer class\n */\nexport class InputSanitizer {\n  private allowedDirectories: string[];\n  private defaultWorkingDir: string;\n\n  constructor(allowedDirectories: string[], defaultWorkingDir: string) {\n    this.allowedDirectories = allowedDirectories.map(dir => path.resolve(dir));\n    this.defaultWorkingDir = path.resolve(defaultWorkingDir);\n  }\n\n  /**\n   * Main validation method that combines all security checks\n   */\n  public validateCommand(command: string, args: string[] = []): ValidationResult {\n    const errors: string[] = [];\n\n    try {\n      // Basic input validation\n      this.validateBasicInput(command, args, errors);\n      \n      // Command whitelist validation\n      this.validateCommandWhitelist(command, errors);\n      \n      // Argument sanitization\n      const sanitizedArgs = this.sanitizeArguments(args, errors);\n      \n      // Injection pattern detection\n      this.detectInjectionPatterns(command, args, errors);\n      \n      // File path validation (for file-related commands)\n      this.validateFilePaths(command, args, errors);\n      \n      if (errors.length > 0) {\n        return {\n          isValid: false,\n          errors\n        };\n      }\n\n      return {\n        isValid: true,\n        errors: [],\n        sanitizedCommand: command.trim(),\n        sanitizedArgs\n      };\n    } catch (error) {\n      errors.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return {\n        isValid: false,\n        errors\n      };\n    }\n  }\n\n  /**\n   * Basic input validation (length, format, etc.)\n   */\n  private validateBasicInput(command: string, args: string[], errors: string[]): void {\n    // Command validation\n    if (!command || typeof command !== 'string') {\n      errors.push('Command must be a non-empty string');\n      return;\n    }\n\n    if (command.length > SECURITY_LIMITS.MAX_COMMAND_LENGTH) {\n      errors.push(`Command too long (max ${SECURITY_LIMITS.MAX_COMMAND_LENGTH} characters)`);\n    }\n\n    if (command.trim() !== command) {\n      errors.push('Command contains leading/trailing whitespace');\n    }\n\n    // Arguments validation\n    if (!Array.isArray(args)) {\n      errors.push('Arguments must be an array');\n      return;\n    }\n\n    if (args.length > SECURITY_LIMITS.MAX_ARGS_COUNT) {\n      errors.push(`Too many arguments (max ${SECURITY_LIMITS.MAX_ARGS_COUNT})`);\n    }\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      if (typeof arg !== 'string') {\n        errors.push(`Argument ${i} must be a string`);\n        continue;\n      }\n      if (arg.length > SECURITY_LIMITS.MAX_ARG_LENGTH) {\n        errors.push(`Argument ${i} too long (max ${SECURITY_LIMITS.MAX_ARG_LENGTH} characters)`);\n      }\n    }\n  }\n\n  /**\n   * Validate command against whitelist\n   */\n  private validateCommandWhitelist(command: string, errors: string[]): void {\n    const normalizedCommand = command.toLowerCase().trim();\n    \n    // Check if command is explicitly blocked\n    if (BLOCKED_COMMANDS.includes(normalizedCommand)) {\n      errors.push(`Command '${command}' is explicitly blocked for security reasons`);\n      return;\n    }\n\n    // Check if command is in whitelist\n    const isWhitelisted = Object.keys(SAFE_COMMANDS).some(key => {\n      const whitelistCommand = SAFE_COMMANDS[key];\n      if (whitelistCommand.name === normalizedCommand) {\n        return true;\n      }\n      // Handle compound commands like 'git status'\n      if (key.includes('-')) {\n        const parts = key.split('-');\n        return parts[0] === normalizedCommand;\n      }\n      return false;\n    });\n\n    if (!isWhitelisted) {\n      errors.push(`Command '${command}' is not in the approved whitelist`);\n    }\n  }\n\n  /**\n   * Sanitize and validate arguments\n   */\n  private sanitizeArguments(args: string[], errors: string[]): string[] {\n    const sanitized: string[] = [];\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      \n      // Check for shell metacharacters\n      for (const metachar of SHELL_METACHARACTERS) {\n        if (arg.includes(metachar)) {\n          errors.push(`Argument ${i} contains dangerous character: '${metachar}'`);\n        }\n      }\n\n      // Remove null bytes and control characters\n      const cleaned = arg.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\n      \n      if (cleaned !== arg) {\n        errors.push(`Argument ${i} contains control characters`);\n      }\n\n      // Basic path traversal prevention\n      if (arg.includes('../') || arg.includes('..\\\\')) {\n        errors.push(`Argument ${i} contains path traversal sequence`);\n      }\n\n      sanitized.push(cleaned.trim());\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Detect command injection patterns\n   */\n  private detectInjectionPatterns(command: string, args: string[], errors: string[]): void {\n    const fullCommand = `${command} ${args.join(' ')}`;\n    \n    for (const pattern of INJECTION_PATTERNS) {\n      if (pattern.test(fullCommand)) {\n        errors.push(`Command contains suspicious pattern: ${pattern.source}`);\n      }\n    }\n\n    // Additional checks for common injection techniques\n    if (fullCommand.includes('$(') || fullCommand.includes('`')) {\n      errors.push('Command substitution detected');\n    }\n\n    if (fullCommand.match(/\\s+[;&|]\\s+/)) {\n      errors.push('Command chaining detected');\n    }\n\n    if (fullCommand.includes('\\\\')) {\n      errors.push('Backslash escape sequences detected');\n    }\n  }\n\n  /**\n   * Validate file paths for file-related commands\n   */\n  private validateFilePaths(command: string, args: string[], errors: string[]): void {\n    const fileCommands = ['cat', 'head', 'tail', 'wc', 'find'];\n    \n    if (!fileCommands.includes(command.toLowerCase())) {\n      return;\n    }\n\n    for (const arg of args) {\n      // Skip non-path arguments (flags, options)\n      if (arg.startsWith('-')) {\n        continue;\n      }\n\n      try {\n        const resolvedPath = path.resolve(this.defaultWorkingDir, arg);\n        \n        // Check if path is within allowed directories\n        const isAllowed = this.allowedDirectories.some(allowedDir => \n          resolvedPath.startsWith(allowedDir)\n        );\n\n        if (!isAllowed) {\n          errors.push(`File path '${arg}' is outside allowed directories`);\n          continue;\n        }\n\n        // Check against blocked paths\n        for (const blockedPath of BLOCKED_FILE_PATHS) {\n          if (resolvedPath.includes(blockedPath.replace('*', ''))) {\n            errors.push(`File path '${arg}' matches blocked pattern: ${blockedPath}`);\n          }\n        }\n\n        // Validate file extension for cat, head, tail commands\n        if (['cat', 'head', 'tail'].includes(command.toLowerCase())) {\n          const ext = path.extname(arg).toLowerCase();\n          const basename = path.basename(arg);\n          \n          const isSafeExtension = SAFE_FILE_EXTENSIONS.some(safeExt => \n            ext === safeExt || basename === safeExt.substring(1) // Handle files like 'README'\n          );\n\n          if (!isSafeExtension && ext !== '') {\n            errors.push(`File extension '${ext}' is not allowed for reading`);\n          }\n        }\n      } catch (pathError) {\n        errors.push(`Invalid file path: ${arg}`);\n      }\n    }\n  }\n\n  /**\n   * Additional method to validate working directory changes\n   */\n  public validateWorkingDirectory(requestedDir: string): ValidationResult {\n    const errors: string[] = [];\n\n    try {\n      const resolvedDir = path.resolve(requestedDir);\n      \n      const isAllowed = this.allowedDirectories.some(allowedDir => \n        resolvedDir.startsWith(allowedDir)\n      );\n\n      if (!isAllowed) {\n        errors.push(`Directory '${requestedDir}' is outside allowed directories`);\n      }\n\n      // Check for directory traversal\n      if (requestedDir.includes('../') || requestedDir.includes('..\\\\')) {\n        errors.push('Directory traversal attempt detected');\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n        sanitizedCommand: resolvedDir\n      };\n    } catch (error) {\n      return {\n        isValid: false,\n        errors: ['Invalid directory path']\n      };\n    }\n  }\n\n  /**\n   * Utility method to escape shell arguments (for logging purposes)\n   */\n  public escapeShellArg(arg: string): string {\n    return `'${arg.replace(/'/g, \"'\\\"'\\\"'\")}'`;\n  }\n\n  /**\n   * Get allowed directories (for informational purposes)\n   */\n  public getAllowedDirectories(): string[] {\n    return [...this.allowedDirectories];\n  }\n}\n\n/**\n * Factory function to create a sanitizer with default configuration\n */\nexport function createSanitizer(allowedDirs?: string[], defaultDir?: string): InputSanitizer {\n  const defaultAllowedDirs = allowedDirs || [process.cwd()];\n  const defaultWorkingDir = defaultDir || process.cwd();\n  \n  return new InputSanitizer(defaultAllowedDirs, defaultWorkingDir);\n}\n