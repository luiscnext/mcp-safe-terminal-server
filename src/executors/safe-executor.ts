/**\n * Safe command executor with resource limits and isolation\n * Executes validated commands in a controlled environment\n */\n\nimport { spawn } from 'child_process';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { \n  CommandResult, \n  ExecutionOptions, \n  CommandExecutionError,\n  SecurityError \n} from '../types/interfaces.js';\nimport { SECURITY_LIMITS } from '../security/whitelist.js';\nimport { InputSanitizer } from '../security/sanitizer.js';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Safe environment variables (minimal set)\n */\nconst SAFE_ENV_VARS = {\n  PATH: '/usr/local/bin:/usr/bin:/bin',\n  HOME: '/tmp',\n  USER: 'mcp-server',\n  LANG: 'en_US.UTF-8',\n  LC_ALL: 'en_US.UTF-8',\n  TERM: 'xterm-256color'\n};\n\n/**\n * Safe command executor class\n */\nexport class SafeCommandExecutor {\n  private sanitizer: InputSanitizer;\n  private logger: Logger;\n  private defaultOptions: ExecutionOptions;\n\n  constructor(\n    sanitizer: InputSanitizer, \n    logger: Logger,\n    defaultOptions: Partial<ExecutionOptions> = {}\n  ) {\n    this.sanitizer = sanitizer;\n    this.logger = logger;\n    this.defaultOptions = {\n      cwd: process.cwd(),\n      timeout: SECURITY_LIMITS.MAX_EXECUTION_TIME,\n      maxOutputSize: SECURITY_LIMITS.MAX_OUTPUT_SIZE,\n      env: SAFE_ENV_VARS,\n      ...defaultOptions\n    };\n  }\n\n  /**\n   * Execute a command safely with full security controls\n   */\n  public async executeCommand(\n    command: string, \n    args: string[] = [], \n    options: Partial<ExecutionOptions> = {}\n  ): Promise<CommandResult> {\n    const startTime = Date.now();\n    const workingDirectory = options.cwd || this.defaultOptions.cwd!;\n    \n    this.logger.info(`Attempting to execute command: ${command} ${args.join(' ')}`, {\n      command,\n      args,\n      workingDirectory,\n      timestamp: new Date().toISOString()\n    });\n\n    try {\n      // Validate command and arguments\n      const validation = this.sanitizer.validateCommand(command, args);\n      if (!validation.isValid) {\n        const error = new SecurityError(\n          `Command validation failed: ${validation.errors.join(', ')}`,\n          'VALIDATION_FAILED'\n        );\n        this.logger.error('Command validation failed', {\n          command,\n          args,\n          errors: validation.errors\n        });\n        throw error;\n      }\n\n      // Validate working directory\n      const dirValidation = this.sanitizer.validateWorkingDirectory(workingDirectory);\n      if (!dirValidation.isValid) {\n        const error = new SecurityError(\n          `Working directory validation failed: ${dirValidation.errors.join(', ')}`,\n          'DIRECTORY_VALIDATION_FAILED'\n        );\n        this.logger.error('Working directory validation failed', {\n          workingDirectory,\n          errors: dirValidation.errors\n        });\n        throw error;\n      }\n\n      // Execute the command\n      const result = await this.executeWithLimits(\n        validation.sanitizedCommand!,\n        validation.sanitizedArgs!,\n        {\n          ...this.defaultOptions,\n          ...options,\n          cwd: dirValidation.sanitizedCommand\n        }\n      );\n\n      const duration = Date.now() - startTime;\n      this.logger.info('Command executed successfully', {\n        command,\n        args,\n        duration,\n        outputSize: result.output.length,\n        exitCode: result.exitCode\n      });\n\n      return {\n        ...result,\n        command: validation.sanitizedCommand!,\n        args: validation.sanitizedArgs!,\n        duration,\n        timestamp: new Date(),\n        workingDirectory: dirValidation.sanitizedCommand!\n      };\n\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.error('Command execution failed', {\n        command,\n        args,\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      if (error instanceof SecurityError || error instanceof CommandExecutionError) {\n        throw error;\n      }\n\n      throw new CommandExecutionError(\n        `Command execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        -1,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n    }\n  }\n\n  /**\n   * Execute command with resource limits and isolation\n   */\n  private async executeWithLimits(\n    command: string,\n    args: string[],\n    options: ExecutionOptions\n  ): Promise<Omit<CommandResult, 'command' | 'args' | 'duration' | 'timestamp' | 'workingDirectory'>> {\n    return new Promise((resolve, reject) => {\n      const timeout = options.timeout || SECURITY_LIMITS.MAX_EXECUTION_TIME;\n      const maxOutputSize = options.maxOutputSize || SECURITY_LIMITS.MAX_OUTPUT_SIZE;\n      \n      let stdout = '';\n      let stderr = '';\n      let outputSize = 0;\n      let isTimedOut = false;\n      let isKilled = false;\n\n      // Prepare safe environment\n      const safeEnv = {\n        ...SAFE_ENV_VARS,\n        ...(options.env || {})\n      };\n\n      // Remove potentially dangerous environment variables\n      const cleanEnv = this.sanitizeEnvironment(safeEnv);\n\n      // Spawn the process with security restrictions\n      const child = spawn(command, args, {\n        cwd: options.cwd,\n        env: cleanEnv,\n        stdio: ['ignore', 'pipe', 'pipe'], // No stdin, capture stdout/stderr\n        detached: false, // Keep process attached for easier cleanup\n        shell: false // Never use shell to prevent injection\n      });\n\n      // Set up timeout\n      const timeoutHandle = setTimeout(() => {\n        isTimedOut = true;\n        this.killProcess(child);\n      }, timeout);\n\n      // Handle stdout with size limits\n      child.stdout?.on('data', (data: Buffer) => {\n        const chunk = data.toString('utf8');\n        outputSize += chunk.length;\n        \n        if (outputSize > maxOutputSize) {\n          this.logger.warn('Output size limit exceeded, killing process', {\n            command,\n            args,\n            outputSize,\n            maxOutputSize\n          });\n          isKilled = true;\n          this.killProcess(child);\n          return;\n        }\n        \n        stdout += chunk;\n      });\n\n      // Handle stderr with size limits\n      child.stderr?.on('data', (data: Buffer) => {\n        const chunk = data.toString('utf8');\n        outputSize += chunk.length;\n        \n        if (outputSize > maxOutputSize) {\n          this.logger.warn('Error output size limit exceeded, killing process', {\n            command,\n            args,\n            outputSize,\n            maxOutputSize\n          });\n          isKilled = true;\n          this.killProcess(child);\n          return;\n        }\n        \n        stderr += chunk;\n      });\n\n      // Handle process completion\n      child.on('close', (code, signal) => {\n        clearTimeout(timeoutHandle);\n        \n        if (isTimedOut) {\n          reject(new CommandExecutionError(\n            `Command timed out after ${timeout}ms`,\n            -1,\n            'Process terminated due to timeout'\n          ));\n          return;\n        }\n        \n        if (isKilled) {\n          reject(new CommandExecutionError(\n            `Command killed due to output size limit (${maxOutputSize} bytes)`,\n            -1,\n            'Process terminated due to resource limits'\n          ));\n          return;\n        }\n        \n        if (signal) {\n          reject(new CommandExecutionError(\n            `Command terminated by signal: ${signal}`,\n            -1,\n            `Process killed by signal ${signal}`\n          ));\n          return;\n        }\n\n        resolve({\n          output: stdout,\n          error: stderr,\n          exitCode: code || 0\n        });\n      });\n\n      // Handle process errors\n      child.on('error', (error) => {\n        clearTimeout(timeoutHandle);\n        this.logger.error('Process spawn error', {\n          command,\n          args,\n          error: error.message\n        });\n        \n        reject(new CommandExecutionError(\n          `Failed to spawn process: ${error.message}`,\n          -1,\n          error.message\n        ));\n      });\n\n      // Ensure process cleanup on unexpected errors\n      process.on('exit', () => {\n        this.killProcess(child);\n      });\n    });\n  }\n\n  /**\n   * Safely kill a process and its children\n   */\n  private killProcess(child: any): void {\n    try {\n      if (child && !child.killed) {\n        // Try graceful termination first\n        child.kill('SIGTERM');\n        \n        // Force kill after a short delay if still running\n        setTimeout(() => {\n          if (child && !child.killed) {\n            child.kill('SIGKILL');\n          }\n        }, 1000);\n      }\n    } catch (error) {\n      this.logger.warn('Error killing process', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Sanitize environment variables to remove dangerous ones\n   */\n  private sanitizeEnvironment(env: Record<string, string>): Record<string, string> {\n    const dangerous = [\n      'LD_PRELOAD', 'LD_LIBRARY_PATH', 'DYLD_LIBRARY_PATH',\n      'PYTHONPATH', 'NODE_PATH', 'RUBYLIB',\n      'BASH_ENV', 'ENV', 'FPATH', 'ZDOTDIR',\n      'IFS', 'PS1', 'PS2', 'PS3', 'PS4',\n      'SHELL', 'HISTFILE', 'HISTFILESIZE'\n    ];\n\n    const clean: Record<string, string> = {};\n    \n    for (const [key, value] of Object.entries(env)) {\n      if (!dangerous.includes(key) && typeof value === 'string') {\n        // Basic value sanitization\n        const cleanValue = value.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\n        if (cleanValue.length < 1000) { // Limit env var length\n          clean[key] = cleanValue;\n        }\n      }\n    }\n\n    return clean;\n  }\n\n  /**\n   * Get execution statistics for monitoring\n   */\n  public getExecutionStats(): {\n    defaultTimeout: number;\n    defaultMaxOutputSize: number;\n    allowedDirectories: string[];\n  } {\n    return {\n      defaultTimeout: this.defaultOptions.timeout!,\n      defaultMaxOutputSize: this.defaultOptions.maxOutputSize!,\n      allowedDirectories: this.sanitizer.getAllowedDirectories()\n    };\n  }\n\n  /**\n   * Test if a command would be allowed (dry run)\n   */\n  public validateCommandOnly(command: string, args: string[] = []): {\n    isValid: boolean;\n    errors: string[];\n  } {\n    const validation = this.sanitizer.validateCommand(command, args);\n    return {\n      isValid: validation.isValid,\n      errors: validation.errors\n    };\n  }\n}\n\n/**\n * Factory function to create a safe executor\n */\nexport function createSafeExecutor(\n  sanitizer: InputSanitizer,\n  logger: Logger,\n  options?: Partial<ExecutionOptions>\n): SafeCommandExecutor {\n  return new SafeCommandExecutor(sanitizer, logger, options);\n}\n